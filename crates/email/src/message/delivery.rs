/*
 * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
 *
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-SEL
 */

use common::Server;

use directory::Permission;
use futures::future::join_all;
use jmap_proto::types::{state::StateChange, type_state::DataType};
use mail_parser::MessageParser;
use std::{borrow::Cow, future::Future};
use store::ahash::AHashMap;
use utils::BlobHash;
use common::expr::functions::ResolveVariable;

use crate::{
    hooks::{self, client::send_delivery_hook_request, Action as HookAction, Modification},
    mailbox::{INBOX_ID, TRASH_ID},
    sieve::ingest::SieveScriptIngest,
};

use super::ingest::{EmailIngest, IngestEmail, IngestSource};

// Simple resolver for delivery hooks (no variables needed)
struct DeliveryResolver;

impl ResolveVariable for DeliveryResolver {
    fn resolve_variable(&self, _variable: u32) -> common::expr::Variable<'_> {
        // Delivery hooks don't use session variables, so return empty
        common::expr::Variable::default()
    }

    fn resolve_global(&self, _variable: &str) -> common::expr::Variable<'_> {
        // Delivery hooks don't use global variables, so return empty
        common::expr::Variable::default()
    }
}

#[derive(Debug)]
pub struct IngestMessage {
    pub sender_address: String,
    pub sender_authenticated: bool,
    pub recipients: Vec<String>,
    pub message_blob: BlobHash,
    pub message_size: u64,
    pub session_id: u64,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum LocalDeliveryStatus {
    Success,
    TemporaryFailure {
        reason: Cow<'static, str>,
    },
    PermanentFailure {
        code: [u8; 3],
        reason: Cow<'static, str>,
    },
}

pub struct LocalDeliveryResult {
    pub status: Vec<LocalDeliveryStatus>,
    pub autogenerated: Vec<AutogeneratedMessage>,
}

pub struct AutogeneratedMessage {
    pub sender_address: String,
    pub recipients: Vec<String>,
    pub message: Vec<u8>,
}

pub trait MailDelivery: Sync + Send {
    fn deliver_message(
        &self,
        message: IngestMessage,
    ) -> impl Future<Output = LocalDeliveryResult> + Send;
}

/// Helper function to handle Sieve script processing after delivery hooks
async fn handle_sieve_script_ingest(
    server: &Server,
    uid: u32,
    raw_message: &[u8],
    parsed_message: Option<mail_parser::Message<'_>>,
    access_token: &common::auth::AccessToken,
    mailbox_ids: Vec<u32>,
    rcpt: &str,
    sender_address: &str,
    sender_authenticated: bool,
    session_id: u64,
    autogenerated: &mut Vec<AutogeneratedMessage>,
) -> trc::Result<super::ingest::IngestedEmail> {
    match server.sieve_script_get_active(uid).await {
        Ok(None) => {
            // No sieve script - ingest to specified mailboxes
            server.email_ingest(IngestEmail {
                raw_message,
                message: parsed_message,
                access_token,
                mailbox_ids,
                keywords: vec![],
                received_at: None,
                source: IngestSource::Smtp {
                    deliver_to: rcpt,
                    is_sender_authenticated: sender_authenticated,
                },
                spam_classify: access_token.has_permission(Permission::SpamFilterClassify),
                spam_train: server.email_bayes_can_train(access_token),
                session_id,
            })
            .await
        }
        Ok(Some(active_script)) => {
            // Run sieve script - it may override mailbox choices
            server.sieve_script_ingest(
                access_token,
                raw_message,
                sender_address,
                sender_authenticated,
                rcpt,
                session_id,
                active_script,
                autogenerated,
            )
            .await
        }
        Err(err) => Err(err),
    }
}

impl MailDelivery for Server {
    async fn deliver_message(&self, message: IngestMessage) -> LocalDeliveryResult {
        // Read message
        let raw_message = match self
            .core
            .storage
            .blob
            .get_blob(message.message_blob.as_slice(), 0..usize::MAX)
            .await
        {
            Ok(Some(raw_message)) => raw_message,
            Ok(None) => {
                trc::event!(
                    MessageIngest(trc::MessageIngestEvent::Error),
                    Reason = "Blob not found.",
                    SpanId = message.session_id,
                    CausedBy = trc::location!()
                );

                return LocalDeliveryResult {
                    status: (0..message.recipients.len())
                        .map(|_| LocalDeliveryStatus::TemporaryFailure {
                            reason: "Blob not found.".into(),
                        })
                        .collect::<Vec<_>>(),
                    autogenerated: vec![],
                };
            }
            Err(err) => {
                trc::error!(
                    err.details("Failed to fetch message blob.")
                        .span_id(message.session_id)
                        .caused_by(trc::location!())
                );

                return LocalDeliveryResult {
                    status: (0..message.recipients.len())
                        .map(|_| LocalDeliveryStatus::TemporaryFailure {
                            reason: "Temporary I/O error.".into(),
                        })
                        .collect::<Vec<_>>(),
                    autogenerated: vec![],
                };
            }
        };

        // Obtain the UIDs for each recipient
        let mut uids: AHashMap<u32, usize> = AHashMap::with_capacity(message.recipients.len());
        let mut result = LocalDeliveryResult {
            status: Vec::with_capacity(message.recipients.len()),
            autogenerated: Vec::new(),
        };

        for rcpt in message.recipients {
            let uid = match self
                .email_to_id(&self.core.storage.directory, &rcpt, message.session_id)
                .await
            {
                Ok(Some(uid)) => uid,
                Ok(None) => {
                    // Something went wrong
                    result.status.push(LocalDeliveryStatus::PermanentFailure {
                        code: [5, 5, 0],
                        reason: "Mailbox not found.".into(),
                    });
                    continue;
                }
                Err(err) => {
                    trc::error!(
                        err.details("Failed to lookup recipient.")
                            .ctx(trc::Key::To, rcpt)
                            .span_id(message.session_id)
                            .caused_by(trc::location!())
                    );
                    result.status.push(LocalDeliveryStatus::TemporaryFailure {
                        reason: "Address lookup failed.".into(),
                    });
                    continue;
                }
            };
            if let Some(status) = uids.get(&uid).and_then(|pos| result.status.get(*pos)) {
                result.status.push(status.clone());
                continue;
            }

            // Obtain access token
            let status = match self.get_access_token(uid).await.and_then(|token| {
                token
                    .assert_has_permission(Permission::EmailReceive)
                    .map(|_| token)
            }) {
                Ok(access_token) => {
                    // Try delivery hook first
                    let parsed_message = MessageParser::new().parse(&raw_message);
                    let hook_result = try_delivery_hook(
                        self,
                        uid,
                        &message.sender_address,
                        &rcpt,
                        &parsed_message,
                        message.message_size as usize,
                    )
                    .await;

                    // Always check for active sieve script after delivery hooks
                    match hook_result {
                        Ok(Some((mailbox_ids, hook_handled))) => {
                            // Hook specified mailbox(es) to file into
                            if hook_handled {
                                trc::event!(
                                    DeliveryHook(trc::DeliveryHookEvent::ActionFileInto),
                                    SpanId = message.session_id,
                                    AccountId = uid,
                                    Details = format!("Filed into mailboxes: {:?}", mailbox_ids),
                                );
                            }

                            // Check if there is an active sieve script
                            handle_sieve_script_ingest(
                                self,
                                uid,
                                &raw_message,
                                parsed_message,
                                &access_token,
                                mailbox_ids,
                                &rcpt,
                                &message.sender_address,
                                message.sender_authenticated,
                                message.session_id,
                                &mut result.autogenerated,
                            )
                            .await
                        }
                        Ok(None) => {
                            // Hook returned Accept or no hooks configured - proceed with normal flow
                            // Check if there is an active sieve script
                            handle_sieve_script_ingest(
                                self,
                                uid,
                                &raw_message,
                                parsed_message,
                                &access_token,
                                vec![INBOX_ID],
                                &rcpt,
                                &message.sender_address,
                                message.sender_authenticated,
                                message.session_id,
                                &mut result.autogenerated,
                            )
                            .await
                        }
                        Err(err) => {
                            // Hook returned Reject
                            Err(err)
                        }
                    }
                }

                Err(err) => Err(err),
            };

            let status = match status {
                Ok(ingested_message) => {
                    // Notify state change
                    if ingested_message.change_id != u64::MAX {
                        self.broadcast_state_change(
                            StateChange::new(uid, ingested_message.change_id)
                                .with_change(DataType::EmailDelivery)
                                .with_change(DataType::Email)
                                .with_change(DataType::Mailbox)
                                .with_change(DataType::Thread),
                        )
                        .await;
                    }

                    LocalDeliveryStatus::Success
                }
                Err(err) => {
                    let status = match err.as_ref() {
                        trc::EventType::Limit(trc::LimitEvent::Quota) => {
                            LocalDeliveryStatus::TemporaryFailure {
                                reason: "Mailbox over quota.".into(),
                            }
                        }
                        trc::EventType::Limit(trc::LimitEvent::TenantQuota) => {
                            LocalDeliveryStatus::TemporaryFailure {
                                reason: "Organization over quota.".into(),
                            }
                        }
                        trc::EventType::Security(trc::SecurityEvent::Unauthorized) => {
                            LocalDeliveryStatus::PermanentFailure {
                                code: [5, 5, 0],
                                reason: "This account is not authorized to receive email.".into(),
                            }
                        }
                        trc::EventType::MessageIngest(trc::MessageIngestEvent::Error) => {
                            LocalDeliveryStatus::PermanentFailure {
                                code: err
                                    .value(trc::Key::Code)
                                    .and_then(|v| v.to_uint())
                                    .map(|n| {
                                        [(n / 100) as u8, ((n % 100) / 10) as u8, (n % 10) as u8]
                                    })
                                    .unwrap_or([5, 5, 0]),
                                reason: err
                                    .value_as_str(trc::Key::Reason)
                                    .unwrap_or_default()
                                    .to_string()
                                    .into(),
                            }
                        }
                        _ => LocalDeliveryStatus::TemporaryFailure {
                            reason: "Transient server failure.".into(),
                        },
                    };

                    trc::error!(
                        err.ctx(trc::Key::To, rcpt.to_string())
                            .span_id(message.session_id)
                    );

                    status
                }
            };

            // Cache response for UID to avoid duplicate deliveries
            uids.insert(uid, result.status.len());

            result.status.push(status);
        }

        result
    }
}

/// Try to call the delivery hook to determine mailbox filing
/// Returns:
/// - Ok(Some((mailbox_ids, handled))) if hook specified mailbox(es) to file into
/// - Ok(None) if hook accepted without modifications (continue normal flow)
/// - Err if hook rejected the message
async fn try_delivery_hook(
    server: &Server,
    user_id: u32,
    sender: &str,
    recipient: &str,
    parsed_message: &Option<mail_parser::Message<'_>>,
    message_size: usize,
) -> trc::Result<Option<(Vec<u32>, bool)>> {
    use std::time::Instant;

    // Build envelope with SMTP hook types
    let envelope = hooks::Envelope {
        from: hooks::Address {
            address: sender.to_string(),
        },
        to: hooks::Address {
            address: recipient.to_string(),
        },
    };

    // Build message with SMTP hook types
    let message = if let Some(msg) = parsed_message {
        let headers = msg
            .root_part()
            .headers()
            .iter()
            .map(|h| {
                (
                    h.name().to_string(),
                    h.value().as_text().unwrap_or_default().to_string(),
                )
            })
            .collect();

        hooks::Message {
            headers,
            server_headers: vec![],
            // TODO: This should be the full raw message, so we can modify it per user
            contents: msg.body_text(0).map(|text| text.as_ref().to_string()).unwrap_or_default(),
            size: message_size,
        }
    } else {
        hooks::Message {
            headers: vec![],
            server_headers: vec![],
            contents: String::new(),
            size: message_size,
        }
    };

    let request = hooks::Request::new(
        jmap_proto::types::id::Id::from(user_id).as_string(),
        user_id,
    )
    .with_envelope(envelope)
    .with_message(message);

    // Get configured delivery hooks
    let delivery_hooks = &server.core.smtp.session.delivery_hooks;

    // If no hooks configured, return None to continue normal flow
    if delivery_hooks.is_empty() {
        return Ok(None);
    }

    // Filter enabled hooks
    let resolver = DeliveryResolver;
    let mut enabled_hooks = Vec::new();
    for hook in delivery_hooks {
        if server.eval_if(&hook.enable, &resolver, 0).await.unwrap_or(false) {
            enabled_hooks.push(hook);
        }
    }

    if enabled_hooks.is_empty() {
        return Ok(None);
    }

    // Run all enabled hooks in parallel
    let mut hook_futures = Vec::new();
    for hook in enabled_hooks {
        let hook_request = request.clone();
        let time = Instant::now();
        hook_futures.push(async move {
            let result = send_delivery_hook_request(hook, hook_request).await;
            (hook, result, time.elapsed())
        });
    }

    let hook_results = join_all(hook_futures).await;

    // Process all hook results
    let mut all_mailbox_ids = Vec::new();
    let mut keep_in_inbox = true;
    let mut should_tempfail = false;
    let mut should_permfail = false;
    let mut any_accept_with_modifications = false;

    for (hook, result, elapsed) in hook_results {
        match result {
            Ok(response) => {
                match response.action {
                    HookAction::Accept => {
                        trc::event!(
                            DeliveryHook(trc::DeliveryHookEvent::ActionAccept),
                            AccountId = user_id,
                            Details = format!("Hook '{}' accepted", hook.id),
                            Elapsed = elapsed,
                        );

                        // Handle response-level skip_inbox flag
                        if response.skip_inbox {
                            keep_in_inbox = false;
                        }

                        // Process modifications
                        for modification in response.modifications {
                            match modification {
                                Modification::FileInto {
                                    folder: mailbox,
                                    mailbox_id,
                                    flags,
                                    special_use,
                                    create,
                                } => {
                                    // Handle mailbox name (could be used for logging or validation)
                                    trc::event!(
                                        DeliveryHook(trc::DeliveryHookEvent::ActionFileInto),
                                        AccountId = user_id,
                                        Details = format!("Hook '{}': Filing into mailbox '{}' (ID: {}) with flags: {:?}, special_use: {:?}, create: {}",
                                            hook.id, mailbox, mailbox_id, flags, special_use, create),
                                    );

                                    let mut target_id = u32::MAX;

                                    // Find mailbox by Id first (similar to sieve ingest logic)
                                    if !mailbox_id.is_empty() {
                                        if let Some(id) = jmap_proto::types::id::Id::from_bytes(
                                            mailbox_id.as_bytes(),
                                        ) {
                                            target_id = id.document_id();
                                        }
                                    }

                                    // Find mailbox by special_use role if ID not found
                                    if let Some(special_use_role) = &special_use
                                        && target_id == u32::MAX
                                    {
                                        if special_use_role.eq_ignore_ascii_case("inbox") {
                                            target_id = INBOX_ID;
                                        } else if special_use_role.eq_ignore_ascii_case("trash") {
                                            target_id = TRASH_ID;
                                        }
                                        // Note: For other special use roles, we'd need access to the mailbox cache
                                        // which isn't available at this level. The actual mailbox lookup
                                        // would need to be done during Sieve script processing.
                                    }

                                    // Use folder name as fallback (though we can't resolve it here without account context)
                                    if target_id == u32::MAX {
                                        // Log that we're using the provided mailbox_id as-is
                                        trc::event!(
                                            DeliveryHook(trc::DeliveryHookEvent::ActionFileInto),
                                            AccountId = user_id,
                                            Details = format!("Hook '{}': Could not resolve mailbox, using folder name: {}", hook.id, mailbox),
                                        );

                                        // Try to parse mailbox_id again as fallback
                                        if let Some(id) = jmap_proto::types::id::Id::from_bytes(
                                            mailbox_id.as_bytes(),
                                        ) {
                                            target_id = id.document_id();
                                        }
                                    }

                                    // Default to INBOX if nothing else works
                                    if target_id == u32::MAX {
                                        target_id = INBOX_ID;
                                    }

                                    if !all_mailbox_ids.contains(&target_id) {
                                        all_mailbox_ids.push(target_id);
                                    }

                                    // TODO: Handle flags - they would need to be applied during message ingestion
                                    // TODO: Handle create - mailbox creation would need to happen during Sieve processing

                                    any_accept_with_modifications = true;
                                }
                            }
                        }
                    }
                    HookAction::Reject => {
                        trc::event!(
                            DeliveryHook(trc::DeliveryHookEvent::ActionReject),
                            AccountId = user_id,
                            Details = format!("Hook '{}' rejected", hook.id),
                            Elapsed = elapsed,
                        );

                        // Check if this rejection should be a tempfail or permfail
                        if hook.tempfail_on_error {
                            should_tempfail = true;
                        } else {
                            should_permfail = true;
                        }
                    }
                }
            }
            Err(err) => {
                // Hook error - log and potentially fail
                trc::event!(
                    DeliveryHook(trc::DeliveryHookEvent::Error),
                    AccountId = user_id,
                    Details = format!("Hook '{}': {}", hook.id, err),
                    Elapsed = elapsed,
                );

                // If tempfail_on_error is set, hook errors should cause tempfail
                if hook.tempfail_on_error {
                    should_tempfail = true;
                }
            }
        }
    }

    // Check for failures - tempfail takes precedence over permfail for retry behavior
    if should_tempfail {
        return Err(trc::EventType::MessageIngest(trc::MessageIngestEvent::Error)
            .ctx(trc::Key::Reason, "Message temporarily rejected by delivery hook")
            .ctx(trc::Key::Code, 451));
    }

    if should_permfail {
        return Err(trc::EventType::MessageIngest(trc::MessageIngestEvent::Error)
            .ctx(trc::Key::Reason, "Message rejected by delivery hook")
            .ctx(trc::Key::Code, 550));
    }

    // If any hook specified mailboxes, file into those mailboxes
    if any_accept_with_modifications {
        // If keep_in_inbox is true, add INBOX_ID
        if keep_in_inbox && !all_mailbox_ids.contains(&INBOX_ID) {
            all_mailbox_ids.push(INBOX_ID);
        }

        trc::event!(
            DeliveryHook(trc::DeliveryHookEvent::ActionFileInto),
            AccountId = user_id,
            Details = format!("Filed into mailboxes: {:?}", all_mailbox_ids),
        );

        return Ok(Some((all_mailbox_ids, true)));
    }

    // If no hooks handled the message, continue with normal flow
    Ok(None)
}
