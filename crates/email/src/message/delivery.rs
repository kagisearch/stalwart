/*
 * SPDX-FileCopyrightText: 2020 Stalwart Labs LLC <hello@stalw.art>
 *
 * SPDX-License-Identifier: AGPL-3.0-only OR LicenseRef-SEL
 */

use common::Server;

use directory::Permission;
use jmap_proto::types::{id::Id, state::StateChange, type_state::DataType};
use mail_parser::MessageParser;
use std::{borrow::Cow, future::Future};
use store::ahash::AHashMap;
use utils::BlobHash;

use crate::{
    mailbox::INBOX_ID,
    message::ingest::IngestedEmail,
    sieve::ingest::{SieveOutputMessage, SieveScriptIngest},
};

use super::{
    delivery_hooks::try_delivery_hook,
    ingest::{EmailIngest, IngestEmail, IngestSource},
};

#[derive(Debug)]
pub struct IngestMessage {
    pub sender_address: String,
    pub sender_authenticated: bool,
    pub recipients: Vec<String>,
    pub message_blob: BlobHash,
    pub message_size: u64,
    pub session_id: u64,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum LocalDeliveryStatus {
    Success,
    TemporaryFailure {
        reason: Cow<'static, str>,
    },
    PermanentFailure {
        code: [u8; 3],
        reason: Cow<'static, str>,
    },
}

pub struct LocalDeliveryResult {
    pub status: Vec<LocalDeliveryStatus>,
    pub autogenerated: Vec<AutogeneratedMessage>,
}

pub struct AutogeneratedMessage {
    pub sender_address: String,
    pub recipients: Vec<String>,
    pub message: Vec<u8>,
}

pub trait MailDelivery: Sync + Send {
    fn deliver_message(
        &self,
        message: IngestMessage,
    ) -> impl Future<Output = LocalDeliveryResult> + Send;
}

impl MailDelivery for Server {
    async fn deliver_message(&self, message: IngestMessage) -> LocalDeliveryResult {
        // Read message
        let raw_message = match self
            .core
            .storage
            .blob
            .get_blob(message.message_blob.as_slice(), 0..usize::MAX)
            .await
        {
            Ok(Some(raw_message)) => raw_message,
            Ok(None) => {
                trc::event!(
                    MessageIngest(trc::MessageIngestEvent::Error),
                    Reason = "Blob not found.",
                    SpanId = message.session_id,
                    CausedBy = trc::location!()
                );

                return LocalDeliveryResult {
                    status: (0..message.recipients.len())
                        .map(|_| LocalDeliveryStatus::TemporaryFailure {
                            reason: "Blob not found.".into(),
                        })
                        .collect::<Vec<_>>(),
                    autogenerated: vec![],
                };
            }
            Err(err) => {
                trc::error!(
                    err.details("Failed to fetch message blob.")
                        .span_id(message.session_id)
                        .caused_by(trc::location!())
                );

                return LocalDeliveryResult {
                    status: (0..message.recipients.len())
                        .map(|_| LocalDeliveryStatus::TemporaryFailure {
                            reason: "Temporary I/O error.".into(),
                        })
                        .collect::<Vec<_>>(),
                    autogenerated: vec![],
                };
            }
        };

        // Obtain the UIDs for each recipient
        let mut uids: AHashMap<u32, usize> = AHashMap::with_capacity(message.recipients.len());
        let mut result = LocalDeliveryResult {
            status: Vec::with_capacity(message.recipients.len()),
            autogenerated: Vec::new(),
        };

        for rcpt in message.recipients {
            let uid = match self
                .email_to_id(&self.core.storage.directory, &rcpt, message.session_id)
                .await
            {
                Ok(Some(uid)) => uid,
                Ok(None) => {
                    // Something went wrong
                    result.status.push(LocalDeliveryStatus::PermanentFailure {
                        code: [5, 5, 0],
                        reason: "Mailbox not found.".into(),
                    });
                    continue;
                }
                Err(err) => {
                    trc::error!(
                        err.details("Failed to lookup recipient.")
                            .ctx(trc::Key::To, rcpt)
                            .span_id(message.session_id)
                            .caused_by(trc::location!())
                    );
                    result.status.push(LocalDeliveryStatus::TemporaryFailure {
                        reason: "Address lookup failed.".into(),
                    });
                    continue;
                }
            };
            if let Some(status) = uids.get(&uid).and_then(|pos| result.status.get(*pos)) {
                result.status.push(status.clone());
                continue;
            }

            uids.insert(uid, result.status.len());

            result.status.push(
                match deliver_to_recipient(
                    self,
                    uid,
                    &rcpt,
                    &message.sender_address,
                    message.sender_authenticated,
                    message.session_id,
                    &raw_message,
                    &mut result.autogenerated,
                )
                .await
                {
                    Ok(ingested_message) => {
                        if ingested_message.change_id != u64::MAX {
                            self.broadcast_state_change(
                                StateChange::new(uid, ingested_message.change_id)
                                    .with_change(DataType::EmailDelivery)
                                    .with_change(DataType::Email)
                                    .with_change(DataType::Mailbox)
                                    .with_change(DataType::Thread),
                            )
                            .await;
                        }

                        LocalDeliveryStatus::Success
                    }
                    Err(err) => match err.as_ref() {
                        trc::EventType::Limit(trc::LimitEvent::Quota) => {
                            LocalDeliveryStatus::TemporaryFailure {
                                reason: "Mailbox over quota.".into(),
                            }
                        }
                        trc::EventType::Limit(trc::LimitEvent::TenantQuota) => {
                            LocalDeliveryStatus::TemporaryFailure {
                                reason: "Organization over quota.".into(),
                            }
                        }
                        trc::EventType::Security(trc::SecurityEvent::Unauthorized) => {
                            LocalDeliveryStatus::PermanentFailure {
                                code: [5, 5, 0],
                                reason: "This account is not authorized to receive email.".into(),
                            }
                        }
                        trc::EventType::MessageIngest(trc::MessageIngestEvent::Error) => {
                            LocalDeliveryStatus::PermanentFailure {
                                code: err
                                    .value(trc::Key::Code)
                                    .and_then(|v| v.to_uint())
                                    .map(|n| {
                                        [(n / 100) as u8, ((n % 100) / 10) as u8, (n % 10) as u8]
                                    })
                                    .unwrap_or([5, 5, 0]),
                                reason: err
                                    .value_as_str(trc::Key::Reason)
                                    .unwrap_or_default()
                                    .to_string()
                                    .into(),
                            }
                        }
                        _ => LocalDeliveryStatus::TemporaryFailure {
                            reason: "Transient server failure.".into(),
                        },
                    },
                },
            )
        }

        result
    }
}

async fn deliver_to_recipient(
    server: &Server,
    uid: u32,
    rcpt: &str,
    sender: &str,
    is_sender_authenticated: bool,
    session_id: u64,
    raw_message: &[u8],
    autogenerated: &mut Vec<AutogeneratedMessage>,
) -> trc::Result<IngestedEmail> {
    // Obtain access token
    let access_token = match server.get_access_token(uid).await.and_then(|token| {
        token
            .assert_has_permission(Permission::EmailReceive)
            .map(|_| token)
    }) {
        Ok(access_token) => access_token,
        Err(err) => return Err(err),
    };

    // Parse original message, sieve may generate changes later
    let original_message = match MessageParser::new().parse(&raw_message) {
        Some(msg) => msg,
        None => {
            return Err(
                trc::EventType::MessageIngest(trc::MessageIngestEvent::Error)
                    .ctx(trc::Key::Code, 550)
                    .ctx(trc::Key::Reason, "Failed to parse e-mail message."),
            );
        }
    };

    // Obtain active sieve script
    let active_script = match server.sieve_script_get_active(uid).await {
        Ok(script) => script,
        Err(err) => return Err(err),
    };

    let mut final_ingested_message = IngestedEmail {
        id: Id::default(),
        change_id: u64::MAX,
        blob_id: Default::default(),
        size: raw_message.len(),
        imap_uids: Vec::new(),
    };

    // Process sieve script, which produces messages to deliver
    let messages = if let Some(active_script) = active_script {
        match server
            .sieve_script_ingest(
                &access_token,
                &original_message,
                &sender,
                &rcpt,
                session_id,
                active_script,
                autogenerated,
            )
            .await
        {
            Ok(sieve_result) => {
                if let Some(reason) = sieve_result.reject_reason.as_ref() {
                    // Rejection
                    let err = trc::EventType::MessageIngest(trc::MessageIngestEvent::Error)
                        .ctx(trc::Key::Code, 571)
                        .ctx(trc::Key::Reason, reason.clone());
                    return Err(err);
                } else if sieve_result.discarded {
                    // Discard (internally looks like success, without ingest)
                    return Ok(final_ingested_message);
                } else {
                    sieve_result.messages
                }
            }
            Err(err) => return Err(err),
        }
    } else {
        vec![SieveOutputMessage {
            raw: raw_message.to_vec(),
            mailbox_ids: vec![INBOX_ID],
            keywords: vec![],
            changed: false,
            did_file_into: false,
        }]
    };

    let can_spam_classify = access_token.has_permission(Permission::SpamFilterClassify);
    let spam_train = server.email_bayes_can_train(&access_token);

    let mut last_temp_error = None;
    let mut has_delivered = false;

    for output_message in messages {
        // Parse message if needed
        let parsed_output_message = if !output_message.changed {
            original_message.clone()
        } else if let Some(message) = MessageParser::new().parse(&output_message.raw) {
            message
        } else {
            trc::event!(
                MessageIngest(trc::MessageIngestEvent::Error),
                Details = "Failed to parse Sieve generated message.",
                SpanId = session_id
            );

            continue;
        };

        // Final delivery parameters
        let mut mailbox_ids: Vec<u32> = output_message.mailbox_ids;
        let mut keywords: Vec<jmap_proto::types::keyword::Keyword> = output_message.keywords;

        match try_delivery_hook(server, uid, &sender, &rcpt, &parsed_output_message).await {
            Ok((hook_mailboxes, hook_flags, skip_inbox)) => {
                for id in hook_mailboxes {
                    if !mailbox_ids.contains(&id) {
                        mailbox_ids.push(id);
                    }
                }

                for k in hook_flags
                    .iter()
                    .map(jmap_proto::types::keyword::Keyword::from)
                {
                    if !keywords.contains(&k) {
                        keywords.push(k);
                    }
                }

                if skip_inbox {
                    mailbox_ids.retain(|&id| id != INBOX_ID);
                }
            }
            Err(err) => return Err(err),
        }

        match server
            .email_ingest(IngestEmail {
                raw_message: &output_message.raw,
                message: Some(parsed_output_message),
                access_token: &access_token,
                mailbox_ids,
                keywords,
                received_at: None,
                source: IngestSource::Smtp {
                    deliver_to: &rcpt,
                    is_sender_authenticated,
                },
                spam_classify: can_spam_classify && !output_message.did_file_into,
                spam_train,
                session_id: session_id,
            })
            .await
        {
            Ok(ingested_message) => {
                has_delivered = true;
                final_ingested_message = ingested_message;
            }
            Err(err) => {
                last_temp_error = err.into();
            }
        }
    }

    if has_delivered || last_temp_error.is_none() {
        Ok(final_ingested_message)
    } else {
        // There were problems during delivery
        #[allow(clippy::unnecessary_unwrap)]
        Err(last_temp_error.unwrap())
    }
}
